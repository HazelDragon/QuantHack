<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>∿</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { background:#000; overflow:hidden; cursor:none; }
canvas { display:block; }

#ui {
  position:fixed; inset:0; pointer-events:none; z-index:10;
  display:flex; flex-direction:column;
  justify-content:flex-end; align-items:center;
  padding-bottom:52px;
}

#question {
  font-family: 'Georgia', serif;
  font-size: clamp(12px,1.6vw,20px);
  font-style: italic;
  letter-spacing: 0.18em;
  color: rgba(255,255,255,0.0);
  text-align: center;
  margin-bottom: 14px;
  transition: color 1.2s, text-shadow 1.2s;
  text-shadow: 0 0 0px white;
}

#path-echo {
  font-family: 'Courier New', monospace;
  font-size: 10px;
  letter-spacing: 0.4em;
  color: rgba(255,255,255,0.12);
  text-transform: lowercase;
  text-align: center;
  margin-top: 10px;
}

#cursor {
  position:fixed;
  width:12px; height:12px;
  margin-left:-6px; margin-top:-6px;
  pointer-events:none; z-index:50;
  border-radius:50%;
  background:rgba(255,255,255,0.6);
  mix-blend-mode:difference;
  transition: transform 0.15s, opacity 0.3s;
  box-shadow: 0 0 20px rgba(255,255,255,0.4);
}

#cursor.hovering {
  transform: scale(3);
}

#flash {
  position:fixed; inset:0; z-index:100; pointer-events:none;
  background:white; opacity:0;
}

#label-left, #label-right {
  position:fixed; top:50%;
  font-family:'Georgia', serif;
  font-style:italic;
  font-size: clamp(11px,1.2vw,15px);
  letter-spacing:0.2em;
  color:rgba(255,255,255,0.0);
  transform:translateY(-50%);
  transition:color 0.4s, text-shadow 0.4s;
  pointer-events:none;
}
#label-left  { left:5%; }
#label-right { right:5%; text-align:right; }
</style>
</head>
<body>
<div id="flash"></div>
<div id="cursor"></div>
<div id="label-left"></div>
<div id="label-right"></div>

<div id="ui">
  <div id="question">what is underneath the wave?</div>
  <div id="path-echo"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ─── Setup ────────────────────────────────────────────────────────────────────
const W = window.innerWidth, H = window.innerHeight;
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(W, H);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
document.body.prepend(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(80, W/H, 0.01, 300);
camera.position.set(0, 0, 0);

// ─── State ────────────────────────────────────────────────────────────────────
const STAGES = [
  {
    q: 'what is underneath the wave?',
    choices: [
      { label: 'the weight of forgetting', side:'left',  hue: 0.55, rgb: [0.1,0.5,1.0],   emissive: 0x1177ff },
      { label: 'the weight of becoming',   side:'right', hue: 0.92, rgb: [1.0,0.15,0.35],  emissive: 0xff1144 },
    ]
  },
  {
    q: 'does the surface remember being still?',
    choices: [
      { label: 'it only knew motion',      side:'left',  hue: 0.38, rgb: [0.05,0.9,0.55],  emissive: 0x00dd66 },
      { label: 'stillness was a dream',    side:'right', hue: 0.72, rgb: [0.55,0.1,1.0],   emissive: 0x8811ff },
    ]
  },
  {
    q: 'where does the frequency resolve?',
    choices: [
      { label: 'into the body',            side:'left',  hue: 0.12, rgb: [1.0,0.7,0.05],   emissive: 0xffaa00 },
      { label: 'into the distance',        side:'right', hue: 0.5,  rgb: [0.05,0.85,0.95], emissive: 0x00ccee },
    ]
  }
];

let stage = 0;
let path = [];
let traveling = false;
let travelT = 0;
let currentPalette = { r:0.05, g:0.05, b:0.15 };
let targetPalette  = { r:0.05, g:0.05, b:0.15 };
let hovered = null; // 'left'|'right'|null

// ─── Mouse ────────────────────────────────────────────────────────────────────
const mouse = { x:0, y:0, nx:0, ny:0 };
const cursorEl = document.getElementById('cursor');

window.addEventListener('mousemove', e => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
  mouse.nx =  (e.clientX / W) * 2 - 1;
  mouse.ny = -(e.clientY / H) * 2 + 1;
  cursorEl.style.left = e.clientX + 'px';
  cursorEl.style.top  = e.clientY + 'px';
});

// ─── Shader Material: Waving Plane ────────────────────────────────────────────
const waveMat = new THREE.ShaderMaterial({
  uniforms: {
    uTime:    { value: 0 },
    uColor:   { value: new THREE.Vector3(0.05, 0.05, 0.15) },
    uMouse:   { value: new THREE.Vector2(0, 0) },
    uTravel:  { value: 0.0 },
    uChoice:  { value: 0.0 }, // -1 left, +1 right
  },
  vertexShader: `
    uniform float uTime;
    uniform float uTravel;
    uniform vec2  uMouse;
    varying vec2  vUv;
    varying float vWave;
    varying vec3  vPos;

    float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453); }
    float noise(vec2 p){
      vec2 i=floor(p), f=fract(p);
      f=f*f*(3.-2.*f);
      return mix(mix(hash(i),hash(i+vec2(1,0)),f.x),
                 mix(hash(i+vec2(0,1)),hash(i+vec2(1,1)),f.x),f.y);
    }

    void main(){
      vUv = uv;
      vec3 pos = position;
      float t = uTime;

      // layered sine waves
      float w  = sin(pos.x*1.2 + t*1.1)*0.55;
            w += sin(pos.x*2.5 - t*0.7 + pos.z*0.3)*0.3;
            w += sin(pos.z*1.8 + t*0.9)*0.4;
            w += cos(pos.x*0.6 + pos.z*0.9 + t*0.5)*0.5;
            w += noise(vec2(pos.x*0.8+t*0.3, pos.z*0.8+t*0.2))*0.8;
            // mouse ripple
            float dx = pos.x - uMouse.x*4.0;
            float dz = pos.z - uMouse.y*2.0;
            float dist = sqrt(dx*dx+dz*dz);
            w += sin(dist*2.0 - t*3.0)*0.4/(dist+0.5);

      // travel warp
      w += sin(pos.z*0.5 + t*4.0)*uTravel*2.0;
      w += noise(vec2(pos.x+t,pos.z+t*2.0))*uTravel*1.5;

      pos.y += w;
      vWave = w;
      vPos  = pos;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.0);
    }
  `,
  fragmentShader: `
    uniform float uTime;
    uniform vec3  uColor;
    uniform float uTravel;
    uniform float uChoice;
    varying vec2  vUv;
    varying float vWave;
    varying vec3  vPos;

    void main(){
      float w = vWave * 0.5 + 0.5;

      // base palette
      vec3 col = mix(uColor*0.3, uColor*1.8, w);

      // iridescent shimmer
      col += vec3(
        sin(vPos.x*0.8+uTime*0.7)*0.08,
        cos(vPos.z*0.6+uTime*0.5)*0.08,
        sin((vPos.x+vPos.z)*0.5+uTime)*0.1
      );

      // foam lines at wave crests
      float foam = smoothstep(0.85,1.0,w)*0.6;
      col += vec3(foam);

      // travel flare
      col += uColor*uTravel*1.5;

      // edge fade
      float edge = smoothstep(0.0,0.15,vUv.x)*smoothstep(1.0,0.85,vUv.x)
                 * smoothstep(0.0,0.12,vUv.y)*smoothstep(1.0,0.88,vUv.y);
      col *= edge;

      gl_FragColor = vec4(col, edge*0.92);
    }
  `,
  transparent: true,
  side: THREE.DoubleSide,
  depthWrite: false,
});

// Two large wave planes (floor + ceiling)
const planeGeo = new THREE.PlaneGeometry(32, 60, 140, 140);
const floor = new THREE.Mesh(planeGeo, waveMat);
floor.rotation.x = Math.PI / 2;
floor.position.set(0, -2.8, -22);
scene.add(floor);

const ceilMat = waveMat.clone();
ceilMat.uniforms = {
  uTime:   { value: 0 },
  uColor:  { value: new THREE.Vector3(0.05, 0.05, 0.15) },
  uMouse:  { value: new THREE.Vector2(0, 0) },
  uTravel: { value: 0.0 },
  uChoice: { value: 0.0 },
};
const ceil = new THREE.Mesh(planeGeo.clone(), ceilMat);
ceil.rotation.x = -Math.PI / 2;
ceil.position.set(0, 2.8, -22);
scene.add(ceil);

// Side walls
const wallMat = waveMat.clone();
wallMat.uniforms = JSON.parse(JSON.stringify({
  uTime:   { value: 0 },
  uColor:  { value: new THREE.Vector3(0.05, 0.05, 0.15) },
  uMouse:  { value: new THREE.Vector2(0, 0) },
  uTravel: { value: 0.0 },
  uChoice: { value: 0.0 },
}));
wallMat.uniforms.uTime  = { value: 0 };
wallMat.uniforms.uColor = { value: new THREE.Vector3(0.05, 0.05, 0.15) };
wallMat.uniforms.uMouse = { value: new THREE.Vector2(0,0) };
wallMat.uniforms.uTravel= { value: 0.0 };
wallMat.uniforms.uChoice= { value: 0.0 };

const wallGeo = new THREE.PlaneGeometry(60, 12, 140, 60);

const wallL = new THREE.Mesh(wallGeo, wallMat);
wallL.rotation.y = Math.PI / 2;
wallL.position.set(-7, 0, -22);
scene.add(wallL);

const wallR = new THREE.Mesh(wallGeo.clone(), wallMat);
wallR.rotation.y = -Math.PI / 2;
wallR.position.set(7, 0, -22);
scene.add(wallR);

const allMats = [waveMat, ceilMat, wallMat];

// ─── Portal Shader ────────────────────────────────────────────────────────────
function makePortal(choice) {
  const mat = new THREE.ShaderMaterial({
    uniforms: {
      uTime:    { value: 0 },
      uColor:   { value: new THREE.Vector3(...choice.rgb) },
      uHover:   { value: 0.0 },
      uTravel:  { value: 0.0 },
    },
    vertexShader: `
      uniform float uTime;
      uniform float uHover;
      varying vec2 vUv;
      varying float vDist;

      void main(){
        vUv = uv;
        vec3 pos = position;
        float angle = atan(pos.y, pos.x);
        float r = length(pos.xy);
        // organic wobble
        pos.x += sin(angle*3.0+uTime*1.5)*0.04*(1.0+uHover);
        pos.y += cos(angle*4.0-uTime*1.2)*0.04*(1.0+uHover);
        pos.z += sin(angle*5.0+uTime*2.0)*0.02;
        vDist = r;
        gl_Position = projectionMatrix*modelViewMatrix*vec4(pos,1.0);
      }
    `,
    fragmentShader: `
      uniform float uTime;
      uniform vec3  uColor;
      uniform float uHover;
      uniform float uTravel;
      varying vec2  vUv;
      varying float vDist;

      float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453); }
      float noise(vec2 p){
        vec2 i=floor(p),f=fract(p);
        f=f*f*(3.-2.*f);
        return mix(mix(hash(i),hash(i+vec2(1,0)),f.x),
                   mix(hash(i+vec2(0,1)),hash(i+vec2(1,1)),f.x),f.y);
      }

      void main(){
        vec2 uv = vUv - 0.5;
        float r = length(uv)*2.0;
        float angle = atan(uv.y, uv.x);

        // spiral
        float spiral = sin(r*8.0 - uTime*2.5 + angle*3.0)*0.5+0.5;
        float ring   = smoothstep(0.82,0.88,r) - smoothstep(0.92,0.98,r);
        float inner  = smoothstep(0.0,0.75,1.0-r);
        float n      = noise(uv*4.0+uTime*0.3)*0.5;

        float glow   = exp(-r*2.5)*0.6;
        float edge   = ring*1.5 + glow;

        vec3 col = uColor*(spiral*0.5+0.5)*(inner*0.6+0.4);
        col += uColor*ring*2.0;
        col += uColor*glow*(1.0+uHover);
        col += vec3(n*0.08);
        col += uColor*uTravel*3.0;

        float alpha = (inner*0.15 + ring*0.9 + glow*0.4)*(1.0+uHover*0.5);
        alpha = clamp(alpha,0.0,1.0);
        if(r>1.0) alpha=0.0;

        gl_FragColor = vec4(col, alpha);
      }
    `,
    transparent: true,
    depthWrite: false,
    side: THREE.DoubleSide,
  });

  const geo = new THREE.CircleGeometry(1.4, 80);
  const mesh = new THREE.Mesh(geo, mat);

  // Hit zone
  const hitGeo = new THREE.CircleGeometry(1.6, 16);
  const hitMat = new THREE.MeshBasicMaterial({ transparent:true, opacity:0, depthWrite:false, side:THREE.DoubleSide });
  const hit = new THREE.Mesh(hitGeo, hitMat);
  mesh.add(hit);

  mesh.userData = { choice, mat, hit };
  return mesh;
}

// ─── Portal Group ─────────────────────────────────────────────────────────────
let portalL = null, portalR = null;

function spawnPortals(stageIdx) {
  if (portalL) scene.remove(portalL);
  if (portalR) scene.remove(portalR);

  const s = STAGES[stageIdx];
  const z = -14;

  portalL = makePortal(s.choices[0]);
  portalL.position.set(-3.2, 0, z);
  scene.add(portalL);

  portalR = makePortal(s.choices[1]);
  portalR.position.set(3.2, 0, z);
  scene.add(portalR);
}

spawnPortals(0);

// ─── Floating Wave Ribbons ────────────────────────────────────────────────────
const ribbons = [];
function makeRibbon(color) {
  const count = 120;
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count * 3);
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  const mat = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.18 });
  const line = new THREE.Line(geo, mat);
  line.userData = {
    offset: Math.random()*Math.PI*2,
    speed:  0.3+Math.random()*0.4,
    amp:    0.5+Math.random()*1.0,
    freq:   0.4+Math.random()*0.8,
    y:      (Math.random()-0.5)*4,
    x:      (Math.random()-0.5)*10,
  };
  scene.add(line);
  ribbons.push(line);
  return line;
}

for (let i=0;i<14;i++) makeRibbon(new THREE.Color().setHSL(0.5+Math.random()*0.4, 0.8, 0.4));

function updateRibbons(t) {
  ribbons.forEach(r => {
    const d = r.userData;
    const pos = r.geometry.attributes.position.array;
    const count = pos.length/3;
    for (let i=0;i<count;i++) {
      const frac = i/(count-1);
      const z = -frac*55;
      const wave = Math.sin(frac*Math.PI*d.freq*6 + t*d.speed + d.offset)*d.amp;
      const wave2= Math.cos(frac*Math.PI*d.freq*4 - t*d.speed*0.7 + d.offset)*d.amp*0.4;
      pos[i*3]   = d.x + wave2;
      pos[i*3+1] = d.y + wave;
      pos[i*3+2] = z;
    }
    r.geometry.attributes.position.needsUpdate = true;
  });
}

// ─── Particles ────────────────────────────────────────────────────────────────
const pCount = 2400;
const pGeo = new THREE.BufferGeometry();
const pPos = new Float32Array(pCount*3);
const pVel = new Float32Array(pCount*3);
for (let i=0;i<pCount;i++) {
  pPos[i*3]   = (Math.random()-0.5)*14;
  pPos[i*3+1] = (Math.random()-0.5)*8;
  pPos[i*3+2] = -(Math.random()*60);
  pVel[i*3]   = (Math.random()-0.5)*0.002;
  pVel[i*3+1] = (Math.random()-0.5)*0.002;
  pVel[i*3+2] = 0.04+Math.random()*0.1;
}
pGeo.setAttribute('position', new THREE.BufferAttribute(pPos,3));
const pMat = new THREE.PointsMaterial({ color:0x88aaff, size:0.025, transparent:true, opacity:0.45 });
const particles = new THREE.Points(pGeo, pMat);
scene.add(particles);

function updateParticles(travelBoost) {
  const spd = 1.0 + travelBoost*5;
  for (let i=0;i<pCount;i++) {
    pPos[i*3]   += pVel[i*3];
    pPos[i*3+1] += pVel[i*3+1] + Math.sin(pPos[i*3+2]*0.1)*0.001;
    pPos[i*3+2] += pVel[i*3+2]*spd;
    if (pPos[i*3+2]>2) {
      pPos[i*3]   = (Math.random()-0.5)*14;
      pPos[i*3+1] = (Math.random()-0.5)*8;
      pPos[i*3+2] = -60;
    }
  }
  pGeo.attributes.position.needsUpdate = true;
}

// ─── UI Helpers ───────────────────────────────────────────────────────────────
const questionEl  = document.getElementById('question');
const pathEchoEl  = document.getElementById('path-echo');
const labelL      = document.getElementById('label-left');
const labelR      = document.getElementById('label-right');
const flashEl     = document.getElementById('flash');

function setQuestion(txt) {
  questionEl.style.color = 'rgba(255,255,255,0.0)';
  setTimeout(() => {
    questionEl.textContent = txt;
    questionEl.style.color = 'rgba(255,255,255,0.55)';
    questionEl.style.textShadow = '0 0 30px rgba(255,255,255,0.25)';
  }, 600);
}

function setLabels(l, r, colL, colR) {
  labelL.textContent = l || '';
  labelR.textContent = r || '';
  labelL.style.color = colL ? `rgba(${(colL>>16)&255},${(colL>>8)&255},${colL&255},0.45)` : 'rgba(255,255,255,0)';
  labelR.style.color = colR ? `rgba(${(colR>>16)&255},${(colR>>8)&255},${colR&255},0.45)` : 'rgba(255,255,255,0)';
}

function clearLabels() { setLabels('','','',''); }

function flash() {
  flashEl.style.transition='none'; flashEl.style.opacity=0.85;
  setTimeout(()=>{ flashEl.style.transition='opacity 0.5s'; flashEl.style.opacity=0; },60);
}

// init labels
setLabels(STAGES[0].choices[0].label, STAGES[0].choices[1].label,
          STAGES[0].choices[0].emissive, STAGES[0].choices[1].emissive);

// ─── Raycaster ────────────────────────────────────────────────────────────────
const raycaster = new THREE.Raycaster();

function checkHover() {
  if (traveling || !portalL) return;
  raycaster.setFromCamera({ x: mouse.nx, y: mouse.ny }, camera);
  const hits = raycaster.intersectObjects([
    portalL.userData.hit, portalR.userData.hit
  ]);
  if (hits.length > 0) {
    hovered = hits[0].object.parent === portalL ? 'left' : 'right';
  } else {
    hovered = null;
  }
  cursorEl.className = hovered ? 'hovering' : '';

  [portalL, portalR].forEach(p => {
    const isHov = (p === portalL && hovered==='left') || (p === portalR && hovered==='right');
    p.userData.mat.uniforms.uHover.value += (isHov ? 1.0 : 0.0 - p.userData.mat.uniforms.uHover.value)*0.1;
  });
}

// ─── Travel ───────────────────────────────────────────────────────────────────
let travelChoice = null;

function doTravel(choice) {
  if (traveling) return;
  traveling = true;
  travelT = 0;
  travelChoice = choice;
  flash();
  clearLabels();
  questionEl.style.color = 'rgba(255,255,255,0)';

  targetPalette = { r: choice.rgb[0], g: choice.rgb[1], b: choice.rgb[2] };
  path.push(choice.label);
}

function onTravelComplete() {
  traveling = false;
  stage++;

  currentPalette = { ...targetPalette };
  const col = new THREE.Vector3(targetPalette.r, targetPalette.g, targetPalette.b);
  allMats.forEach(m => m.uniforms.uColor.value.copy(col));
  pMat.color.setRGB(targetPalette.r, targetPalette.g, targetPalette.b);
  ribbons.forEach(r => r.material.color.setRGB(targetPalette.r*0.8, targetPalette.g*0.8, targetPalette.b*0.8));

  if (stage < STAGES.length) {
    spawnPortals(stage);
    setQuestion(STAGES[stage].q);
    const s = STAGES[stage];
    setTimeout(()=>{
      setLabels(s.choices[0].label, s.choices[1].label,
                s.choices[0].emissive, s.choices[1].emissive);
    }, 1200);
  } else {
    // End
    if (portalL) scene.remove(portalL);
    if (portalR) scene.remove(portalR);
    portalL = portalR = null;
    const echo = path.join(' ∿ ');
    pathEchoEl.textContent = echo;
    setQuestion('you have passed through');
    clearLabels();
  }
}

// Click
window.addEventListener('click', () => {
  if (traveling || !portalL) return;
  raycaster.setFromCamera({ x: mouse.nx, y: mouse.ny }, camera);
  const hits = raycaster.intersectObjects([portalL.userData.hit, portalR.userData.hit]);
  if (hits.length > 0) {
    const choice = hits[0].object.parent === portalL
      ? STAGES[stage].choices[0]
      : STAGES[stage].choices[1];
    doTravel(choice);
  }
});

// ─── Animate ──────────────────────────────────────────────────────────────────
const clock = new THREE.Clock();
let t = 0;
let camX = 0, camY = 0;

function animate() {
  requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.05);
  t += dt;

  // palette lerp
  currentPalette.r += (targetPalette.r - currentPalette.r)*0.02;
  currentPalette.g += (targetPalette.g - currentPalette.g)*0.02;
  currentPalette.b += (targetPalette.b - currentPalette.b)*0.02;

  const col = new THREE.Vector3(currentPalette.r, currentPalette.g, currentPalette.b);

  // Travel progress
  let travelBoost = 0;
  if (traveling) {
    travelT = Math.min(1, travelT + dt*0.7);
    const ease = travelT < 0.5 ? 4*travelT*travelT*travelT : 1 - Math.pow(-2*travelT+2,3)/2;
    travelBoost = ease;

    // Forward rush
    camera.position.z = -ease*18;
    camera.fov = 80 + ease*25;
    camera.updateProjectionMatrix();

    // Update travel uniforms
    allMats.forEach(m => { m.uniforms.uTravel.value = ease; });
    if (portalL) portalL.userData.mat.uniforms.uTravel.value = ease;
    if (portalR) portalR.userData.mat.uniforms.uTravel.value = ease;

    if (travelT >= 1) {
      camera.position.z = 0;
      camera.fov = 80;
      camera.updateProjectionMatrix();
      allMats.forEach(m => { m.uniforms.uTravel.value = 0; });
      onTravelComplete();
    }
  } else {
    // Gentle float
    camX += (mouse.nx*0.5 - camX)*0.03;
    camY += (mouse.ny*0.3 - camY)*0.03;
    camera.position.x = camX + Math.sin(t*0.18)*0.15;
    camera.position.y = camY + Math.cos(t*0.12)*0.1;
    camera.position.z = 0;
    camera.fov = 80;
    camera.updateProjectionMatrix();
  }

  // Update wave shaders
  allMats.forEach(m => {
    m.uniforms.uTime.value = t;
    m.uniforms.uColor.value.copy(col);
    m.uniforms.uMouse.value.set(mouse.nx, mouse.ny);
  });

  // Portals
  if (portalL) portalL.userData.mat.uniforms.uTime.value = t;
  if (portalR) portalR.userData.mat.uniforms.uTime.value = t;

  // Wobble portals
  if (portalL && !traveling) {
    portalL.rotation.z = Math.sin(t*0.6)*0.06;
    portalR.rotation.z = Math.cos(t*0.7)*0.06;
    portalL.position.y = Math.sin(t*0.5)*0.12;
    portalR.position.y = Math.cos(t*0.55+1)*0.12;
  }

  updateRibbons(t);
  updateParticles(travelBoost);
  checkHover();

  camera.lookAt(camX*0.1, camY*0.1, -50);

  renderer.render(scene, camera);
}

setQuestion(STAGES[0].q);
animate();

window.addEventListener('resize', () => {
  const W=window.innerWidth, H=window.innerHeight;
  camera.aspect = W/H;
  camera.updateProjectionMatrix();
  renderer.setSize(W,H);
});
</script>
</body>
</html>
